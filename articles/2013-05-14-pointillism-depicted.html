<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
		<meta content="Benjamin Bill Planche" name="author">
		<meta content="Portfolio of Benjamin (Bill) Planche, aka Aldream. About image processing, computer graphics, web experiments,..." name="description">
		<meta content="aldream, benjamin, planche, bill, blog, web, image, graphics, mesh, tesselation, tween, cube, sphere" name="keywords">
		<meta content="index,follow" name="robots">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Aldream - Mesh Breeding</title>
        <meta name="viewport" content="width=device-width">

		<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro|Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="/css/normalize.css"/>
        <link rel="stylesheet" href="/css/main.css"/>
		<link href="/css/syntaxhighlighter_3.0.83/shCore.css" rel="stylesheet" type="text/css" />
		<link href="/css/syntaxhighlighter_3.0.83/shThemeDefault.css" rel="stylesheet" type="text/css" />
        <script src="/js/vendor/modernizr-2.6.2.min.js"></script>
    </head>
    <body id="blog">
			<!--[if lt IE 7]>
				<p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
			<![endif]-->

			<!-- Add your site or application content here -->
			<header id="main-header">
				<h1><a href="/">Aldream</a></h1>
				<nav id="menu-top">
					<ul>
						<a href="/blog"><li>Blog</li></a>
						<a href="/demo"><li>Demo</li></a>
						<a href="/projects"><li>Projects</li></a>
						<a href="/about"><li>About</li></a>
					</ul>
				</nav>
				<nav id="menu-top-mini">
					<ul>
						<li><a href="/blog" title="Blog"><img width=22 alt="Blog" src="/img/glyphicons-color/book-blue.png"/></a></li>
						<li><a href="/demo" title="Demo"><img width=25 alt="Demo" src="/img/glyphicons-color/eye-green.png"/></a></li>
						<li><a href="/projects" title="Projects"><img width=25 alt="Projects" src="/img/glyphicons-color/star-yellow.png"/></a></li>
						<li><a href="/about" title="About"><img width=25 alt="About" src="/img/glyphicons-color/user-red.png"/></a></li>
					</ul>
				</nav>
			</header>
			<section id="blog-article">
				<h1>Article</h1>
				<article class="span3">
					<div>
<h1>Mesh Breeding</h1>

<p>To conclude my series of articles describing the tricks I learned and used for the <a href="http://js1k.com/2013-spring/" title="JS1K 2013">JS1K Spring-2013 challenge</a>, I will now explain how <em><strong>Pointillism</em></strong> (js1k demo / local demo) was done, since it received such nice reviews.</p>
<p>I will thus cover the <strong>lightweight procedural method</strong> used to generate the landscape, and the <strong><em>pointillist-like rendering</em></strong> I will assume you read my previous articles (Mesh Breeding and especially Painter's Algorithm), since they already cover the main notions of 3D generation and rendering.

$
\newcommand{\hvectwo}[2]
{
   \begin{pmatrix} #1 \!\!\! & , & \!\!\! #2 \end{pmatrix}
}
\newcommand{\hvecthree}[3]
{
   \begin{pmatrix} #1 \!\!\! & , & \!\!\! #2 & \!\!\! , & \!\!\! #3 \end{pmatrix}
}
\newcommand{\hvecfour}[4]
{
   \begin{pmatrix} #1 \!\!\! & , & \!\!\! #2 & \!\!\! , & \!\!\! #3 & \!\!\! , & \!\!\! #4 \end{pmatrix}
}
\newcommand{\arraytwo}[2]
{
   \begin{bmatrix} #1 \!\!\! & , & \!\!\! #2 \end{bmatrix}
}
$

<h2>Generating the landscape</h2>

<p>The creation of fractal landscapes (https://en.wikipedia.org/wiki/Fractal_landscape) is a famous and well-covered subject in Computer Graphics. Using stochastic algorithms emphasizing realism or performance, the aim is to generate a landform (mountains, lakes, plateau,...) and then to <i>give life to it</i> by painting it using Nature's logic (light-green meadow in flat sunny areas, white snow clinging to peaks,...), or by populating it with other 3D objects (trees, buildings,... <small>which can also be procedurally generated btw</small>).</p>

<h3>Topography</h3>
<p>A simple landform (continuous surface without caves) can be represented by a 2D <em>heightmap</em>, a matrix containing the elevation of sampled points. If we get such a matrix, it is thus possible to convert it into a 3D landscape, by using its indices as x and y coordinates, and the elevation as z.</p>

<p>A method to generate such heightmap must respect some criteria. It must be <em>pseudo-random</em> (random enough to be stochastic and allow a wide range of landforms, but predictable enough to give some controls over it), exhibit <em>fractal behavior</em> (covering both the global molding and the detailed surface), and be <em>coherent</em>, ie without any discontinuity (unless we want special topographic features like cliffs).</em>

<p>Some noise functions meet those conditions. The <strong>Perlin (http://mrl.nyu.edu/~perlin/) Noise</strong> is especially famous and widely used, being quite easy to implement though giving smooth results.</p>

<p>Alas, &laquo; easy to implement &raquo; doesn't always means &laquo; short &raquo;. Even though it can be condensed in few lines, it was still too long for a 1K demo. I thus opted for another well-know method: the <strong>Midpoint-Displacement algorithm</strong>. Its main idea is, given a 2D grid containing various values, to insert intermediate ones between each couple. The new values are computed using the mean of the surrounding points and adding a small error to it to generate new details. The amplitude of the error must be inversely proportional to the iteration / to the distance between the points to give the fractal-like result (the addition of big errors in the first iterations gives the landscape its global shape while the following iterations add smaller and smaller details to the surface).</p>

<p>Here is a simple implementation of this algorithm for a 2D map, using modulos to evaluate the position of each points in the current square:</p>
<script type="syntaxhighlighter" class="brush: js"><![CDATA[
///
// Generate new intermediate points (and thus details) to the given heightmap, by using stochastic interpolation (Midpoint-Displacement algorithm).
// Parameters:
//	- currentMap : Array of points (square matrix)
//	- amplitude : Alterations amplitude
// Returns: New map, more detailed
///
function ComputeMidPointDisplacement(currentMap, amplitude) {
	var dim = Math.sqrt(currentMap.length)+.5|0;
	var newDim = 2*dim - 1; // We want to add 1 new element between each couple of them, so the size will increase of dim-1.
	var newMap = [];
	
	for (var i = newDim; i--;) for (var j = newDim; j--;) {
		var iMap = i*newDim + j,
			iSMap = dim*(i>>1) + j/2|0; // Index of the top-left corner of the square in the smaller matrix.
		// JS trick: Math.floor(X) = 0|X if X positive, and X>>Y = 0|(X/(2*Y))
		newMap[iMap] =
			i%2?
				j%2?// Element on an odd row and odd col: it corresponds to a square center, so we populate it as shown in the following ascii schema:
					// 1  0  1		with X representing the current element, and the numbers the weight used to compute the mean value.
					// 0  X  0		So here, we use the value of the corners of the parent square to get the value of the new point, and we add a small
					// 1  0  1		error to it.
					((currentMap[iSMap] + currentMap[iSMap+1] +currentMap[iSMap+dim] +currentMap[iSMap+dim+1]) / 4 + amplitude * (.5 - Math.random()))
					
				:	// Element on an odd row and even col: we give it the avg of the elements on the prev. and next cols:
					// 1  0  0		Example
					// X  0  0
					// 1  0  0
					(currentMap[iSMap] + currentMap[iSMap+dim]) / 2
			:
				j%2?// Element on an even row and odd col: we give it the avg of the elements on the prev. and next rows:
					// 1  X  1		Example
					// 0  0  0
					// 0  0  0
					(currentMap[iSMap] + currentMap[iSMap+1]) / 2
				:	// Element on an even row and even col: it's one of the square corners, so we just give it the orig. val.:
					currentMap[iSMap];
		
		// Just to keep the values into control (boundaries):
		if (newMap[iMap] > 1) { newMap[iMap] = 1; }
		if (newMap[iMap] < 0) { newMap[iMap] = 0; }
	}
	
	return newMap;
}

// -------------------------------
// HOW TO USE IT - (Dirty) Example

function GenerateNewStartingMap() { // Generate a new random 2x2 map.
	for (var newMap = [], it = 4; it-- ; newMap[it] = Math.random()*10); return newMap;
}

var nbMaxIterations = 8,	// Max number of procedural iterations
	h = 16;					// Amplitude of the error
for (var i = nbMaxIterations, heightMap = GenerateNewStartingMap(); i--; heightMap = ComputeMidPointDisplacement(heightMap, h /= 2));
]]></script>

<p>One problem of this algorithm is the squared artifacts it generates. A variant has been developed, the <strong>Diamond-Square algorithm</strong>(https://en.wikipedia.org/wiki/Diamond-square_algorithm)(http://www.gameprogrammer.com/fractal.html), but this requires another step per square, lengthening the function. To <i>partially</i> prevent those artifacts without exceeding the size limit, I made a mix of both methods, using both points from the previous map and the already generated points from the new one to evaluate the value of the mid points:</p>

<script type="syntaxhighlighter" class="brush: js"><![CDATA[
		...
		newMap[iMap] =
			(i%2?
				j%2?// Element on an odd row and odd col: it corresponds to a square center, so we populate it as shown in the following ascii schema:
					// 3  0  0		with X representing the current element, and the numbers those used to eval. it.
					// 0  X  1		It's kind of a mix between the midpoint displacement and the diamond-square algo: we try to reduce the artifacts 
					// 0  1  1		the 1st algo may generate, without the 2nd step required by the other.
					(newMap[iMap+newDim] + newMap[iMap+1] + newMap[iMap+1+newDim] + 3*currentMap[iSMap]) / 6
					// or (newMap[iMap+newDim] + newMap[iMap+1] + 2*currentMap[iSMap]) / 4 if like me you don't have enough place for the extra weight.
					
				:	// Element on an odd row and even col: we give it the avg of the elements on the prev. and next cols:
					// 1  0  0		Example
					// X  0  0
					// 1  0  0
					(currentMap[iSMap] + currentMap[iSMap+dim]) / 2
			:
				j%2?// Element on an even row and odd col: we give it the avg of the elements on the prev. and next rows:
					// 1  X  1		Example
					// 0  0  0
					// 0  0  0
					(currentMap[iSMap] + currentMap[iSMap+1]) / 2
				:	// Element on an even row and even col: it's one of the square corners, so we just give it the orig. val.:
					currentMap[iSMap]
			) + amplitude * (.5 - Math.random()); // By adding errors to every point (even the previously fixed one), we lose in predictability but reduce a bit the visibility of the remaining artifacts.
		...
]]></script>

[[1D demo vs 1D demo with pseudo algo]]
[[2D demo vs 2D demo with pseudo algo]]
[[ adding some codes ]]

<h3>Coloring</h3>

<p>Given your heightmap, it's quite easy to <em>assign color to every point depending on its elevation</em>: if the value equals the min. boundary, then paint it light blue to represent water; if it's above a given limit then make it white as snow; if it's between then make a gradient from vegetal-green to rocky-brown with a function using the height ; ...</p>

<p>But getting a realist-enough result needs much tweaking, and also more inputs.</p>

<p>One of the keys to give more depth and realism to a landscape is to take <strong>lighting</strong> into account. Computing shadows is out of question given our 1K limit, but simulating penumbra is easy using the <strong>incline</strong>. The traditionnal method to evaluate how much sunlight a surface get is by computing the dot-product of the surface's normal (or local gradient) and the unit vector representing the direction from the center of the surface to the point representing the Sun. We thus get the value of the cosine of the angle between these two vectors - value which is proportional to the luminance of the surface. By multiplying it with the <em>reflectivity</em> of the surface (high for snow, low for vegetation, ...), you get your color's <em>lightness</em>.</p>

<p>Alas, here again, evaluating the local gradient and using a real dot-product was too long, so I approximated both operations by the following: $pseudoGrad\arraytwo{i}{j}=(2 \cdot heightMap\arraytwo{i+1}{j+1}-heightMap\arraytwo{i+1}{j}-heightMap\arraytwo{i}{j+1}) \cdot 26$. The shifting and incompletness of the evaluation of the gradient and its projection simulate the dot-product with a sun positioned somewhere north-east of the map...</p>

<p>But we can use this value for <em>much more than simply evaluating the lightness</em>. Lighting also impacts directly the elements in the landscapes. For instance, vegetation isn't the same in sunny places than in the dark coombes. And the quantity of snow isn't only function of the elevation but also of the surface's penumbra. So by also using our pseudo-derivated value as input for the computations of the other color components (hue and saturation), we can give to our landscape much more nuances, simulating some natural phenomena.</p>

<p>For each point $(i,j, height)$ to display, I thus evaluate its color with the <i>highy-personal-and-not-so-reusable</i> following code (just so you can see the structure):</p>

<script type="syntaxhighlighter" class="brush: js"><![CDATA[
var pseudoGrad = 2+(2*heightMap[i*dim+j+dim+1]-heightMap[i*dim+j+dim]-heightMap[i*dim+j+1])*26,
	pseudoHeight = height-pseudoGrad;
ctx.fillStyle = ctx.strokeStyle = 'hsl('+[ // Using coercion for the ","
	25*(	// Hue
		(WATER_LVL<height)? 25/height					// Green to brown
		: 7 											// Blue
		), // can be approximated by: hue = 13.7*height*height-244*height+1143
	25*(	// Saturation	
		(WATER_LVL<height)? pseudoGrad*14/height/height	// Ground saturation: medium, depending on the incline/height, giving us different kinds of veget.
		: pseudoHeight									// Water saturation: high
		)+'%',
	(25*(	// Lightness
		(SNOW_LVL_DEC<pseudoHeight)? pseudoGrad					// Bright snow with random noise
		: (BEACH_LVL<height)? pseudoGrad/height*2				// Vegetation
		: (WATER_LVL<height)? pseudoGrad						// Bright sand
		: 1.8+Math.random()*.2									// Water with random waves
		))-6*Math.cos(i/47*Math.cos(height/3+j/57)+pseudoHeight)// Some not-very-random-but-good-enough shadows/lights (casted by clouds for instance)
]+'%)';
]]></script>

<p>&laquo;<i>It still looks ugly.</i>&raquo; Right, but we are adding relief effects to a flat surface, how can it look but disturbing? Let's now play with 3D.</p>

<h3>Put everything into relief</h3>
	
<p>Almost nothing new here. The whole projection and rendering stuff has been covered in the previous articles. We just have to take each point $(i, j, height)$ of the heightmap and evaluate the position of the corresponding vertex $\hvecthree{x}{y}{z}$ with:</p>

$$x = i \cdot d \\ y = j \cdot d \\ d = landscape.size  \div heightMap.size \\ z = height \cdot k \text{ ( k constant)}$$

<p>... then project it into screen coordinates.</p>
<p>To check if the point should be displayed or not, ie. if it isn't hidden behind other features, we could use again the Painter's algorithm. This is what I used for the demo Loom (XXXXXXXXXXX).</p>

[[ Loom ]]

<p>The problem of this method is that it implies to sort an array containing all the elements (simple vertices or surfaces) waiting to be drawn. That is quite a <i>heavy</i> operation, given the level of details of our landscape. This is why I have to reduce the details when moving around, or else the browser wouldn't be able to ensure a correct framerate <small>(and would probably crash)</small>. I was though satisfied with the result, and ready to publish it.</p>

<h3>Another way to see the world</h3>

<p>While polishing some aspect of the demo, I came accross this article (http://www.romancortes.com/blog/1k-rose) made by Román Cortés (XXXX) about his great entry for JS1K 2012 (http://js1k.com/2012-love/). There, he describes in details the rendering method he used, combining the use of a <strong>z-buffer</strong> and a <strong>Monte-Carlo surface sampling</strong>. I thus decided to try to apply it to my landscapes, and create a new demo.</p>

<p>The idea behind this method is the following:</p>
<ul>
	<li>We define our whole scene by a bijective function $f:\hvectwo{a}{b} \mapsto \hvecfour{x}{y}{z}{color}$ with $\hvectwo{a}{b} \in \arraytwo{0.0}{1.0} \times \arraytwo{0.0}{1.0}$ and $x$, $y$, $z$ the coordinates of the vertex matching the input. It implies to find a way to express each element as an explicit-surface with its own unique domain.</li>
	<li>We keep two buffers of the same length $canvas.width \times canvas.height$ : one for the $color$ values of the projected elements (the  <em>z-canvas</em>), and one for their $depth$ values (the <em>z-buffer</em>).</li>
	<li>Each frame, we sample randomly a high number of points $\hvectwo{a}{b}$, evaluate the corresponding vertex using $f$, and project it into $\hvecfour{p_x}{p_y}{depth}{color}$. If the pixel $\hvectwo{p_x}{p_y}$ as already been drawn, we check the z-buffer:
		<ul>
			<li>If $zBuffer\arraytwo{p_x}{p_y} < depth$, it means the element is actually behind the one already drawn, so we do nothing.</li>
			<li>Else, the element should be represented above, so we update both $canvas\arraytwo{p_x}{p_y}$ with $color$ and $zBuffer\arraytwo{p_x}{p_y}$ with $depth$.</li>
		</ul>
	</li>
	<li>As long as the camera and scene are static, we can keep drawing more random points each frame, until reaching a satisfactory density. If movements are required, then both canvas and z-buffer must be cleared <small>(unless you keep the 3D information of each points and reproject them accordingly to the new transform.)</small></li>
</ul>
<p>However, we need some adaptations to use this method on our landscape. We don't have a <em>continuous</em> function to pick vertices out of our 2D <em>discrete</em> heightmap. We need a way to evaluate the height of the points all over our surface, and not only at the nodes.</p>

<p><strong>Triangulation and barycentric interpolation</strong> do the trick nicely. Here is how it works:</p>
<ol>
	<li>Given a point $P = \hvectwo{x}{y} \in \mathbb{R}^2$, find in which square $ABCD$ (unit square in the heightmap) it is, with $A = \hvectwo{X}{Y}$, $B = \hvectwo{X+1}{Y}$, $C = \hvectwo{X}{Y+1}$ and $D = \hvectwo{X+1}{Y+1}$, $X$ and $Y$ being the truncated value of $x$, $y$, ie $\hvectwo{X}{Y} \in \mathbb{N}^2$.</li>
    <li>Estimate in which triangle - $ABD$ or $ACD$ - $P$ is, using the condition: $d_x > d_y \to P \in ABD$ with $d_x$, $d_y$ the decimal part of $x$, $y$.</li>
    <li>Evaluate the height of the point using linear interpolation with the implicit barycentric coordinates as weights(http://www.farinhansford.com/dianne/teaching/cse470/materials/BarycentricCoords.pdf):
		<ul>
			<li>if $P \in ABD$, $height = h(B) + [h(A) - h(B)] \cdot (1-d_x) + [h(D) - h(B)] \cdot d_y$.</li>
			<li>if $P \in ACD$, $height = h(C) + [h(A) - h(C)] \cdot (1-d_y) + [h(D) - h(C)] \cdot d_x$, with $h(K=\hvectwo{X}{Y}) = heightMap\arraytwo{X}{Y}$.</li>
		</ul></li>
</ol>

[[ Demo color interpolation ]]

<p>We are thus able to describe explicitly our surface. We can now wrap this whole process into a function $g: \hvectwo{x}{y} \in \mathbb{R}^2 \mapsto \hvecfour{x}{y}{height}{color}$ ($color$ being computed by a function similar to the one described previously) and plug it to the Monte-Carlo sampling by defining $f$ as $f\hvectwo{a}{b} = g\hvectwo{a \cdot heightMap.width}{b \cdot heightMap.height}$.</p>

<p>Nothing else to do but to put everything together, and that's it:</p>

[[ Demo ]]

<h2>Conclusion</h2>

<p>With this article, I've finished covering the mathematical angle in my JS1K '13 demos. I was thinking about briefly describing the implementation process and the useful Javascript tricks, but <a href="http://twitter.com/BlurSpline" title=" Twitter - @BlurSpline">@BlurSpline</a> did this great presentation already (http://slid.es/zz85/the-js1k-experience).</p>

<p>To conclude, I highly recommend such contests to any enthusiast-programmer - at least to try once. They represent an immersive playground to improve your skills. They restrict your ressources (time, size, ...) wich results in a boost of your motivation and efficiency. And finally, they offer a great opportunity to meet highly talented people sharing the same masochistic relish as you, and to learn from each other.</p>

<div class="quote"><p>IMHO best compression scheme: imagination+time+math skills.</p><footer>Philippe Deschaseaux, winner of JS1k Spring '13 (<a href="ps://twitter.com/ehouais/status/313943128962908160" title="Twitter Status">here</a>)</footer></div>

<h3>References</h3>
<ol>
	<li id="refed-1"><a class="refed" href="#refing-1">^</a> Steven Wittens - Article - &laquo; Making Worlds 1 - Of Spheres and Cubes &raquo; - <a href="http://acko.net/blog/making-worlds-1-of-spheres-and-cubes/" title="Steven Wittens - Article - &laquo; Making Worlds 1 - Of Spheres and Cubes &raquo;">acko.net/blog/making-worlds-1-of-spheres-and-cubes</a></li>
	<li id="refed-2"><a class="refed" href="#refing-2">^</a> Iñigo Quílez - Article - &laquo; Useful Little Functions &raquo; - <a href="http://www.iquilezles.org/www/articles/functions/functions.htm" title="Iñigo Quílez - Article - &laquo; Useful Little Functions &raquo;">iquilezles.org/www/articles/functions/functions.htm</a></li>
	<li id="refed-4"><a class="refed" href="#refing-'">^</a> Jeff Atwood: &laquo; Don't Reinvent The Wheel, Unless You Plan on Learning More About Wheels &raquo; - <a href="http://www.codinghorror.com/blog/2009/02/dont-reinvent-the-wheel-unless-you-plan-on-learning-more-about-wheels.html" title="Jeff Atwood: &laquo; Don't Reinvent The Wheel, Unless You Plan on Learning More About Wheels &raquo;">codinghorror.com/blog/2009/02/dont-reinvent-the-wheel-unless-you-plan-on-learning-more-about-wheels.html</a></li>
</ol>
						<footer>
							<time datetime="2013-04-13">2013-04-23</time>
							<a href="https://twitter.com/share" class="twitter-share-button" data-text="The Painter'S Algorithm" data-via="b_aldream" data-lang="en">Tweet</a>
						</footer>
						<div id="disqus_thread"></div>
						<script type="text/javascript">
							/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
							var disqus_shortname = 'aldream'; // required: replace example with your forum shortname

							/* * * DON'T EDIT BELOW THIS LINE * * */
							(function() {
								var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
								dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
								(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
							})();
						</script>
						<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
							<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
							
					</div>
				</article>
			</section>
			<footer id="page-footer">&copy; Aldream / Benjamin (Bill) Planche 2013 - <a href="#blog-article" title="Up">Fly high</a></footer>


        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="/js/vendor/jquery-1.9.0.min.js"><\/script>')</script>
        <script src="/js/plugins.js"></script>
        <script src="/js/main.js"></script>
		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({
				TeX: { extensions: ["autobold.js"] },
				tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
			});
		</script>
		<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
		<script type="text/javascript" src="/js/vendor/syntaxhighlighter_3.0.83/shCore.js"></script>
		<script type="text/javascript" src="/js/vendor/syntaxhighlighter_3.0.83/shBrushJScript.js"></script>
		<script>
			// Syntax Highlighting:
			SyntaxHighlighter.all()
			
			// Twitter buttons:
			!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
			
			function AdaptImageToScreenSize() {
				if (innerWidth > 690) {
					if (!this.alreadyWide) {
						$('.wideImg').each(function(){
							var src = $(this).attr('src');
							var srcArray = src.split('.');
							src = srcArray.pop();
							src = srcArray.join('.') + '-wide.' + src;
							$(this).attr('src', src);
							$(this).attr('width', 620);
						});
						this.alreadyWide = true;
					}
				}
				else {
					if (this.alreadyWide) {
						$('.wideImg').each(function(){
							var src = $(this).attr('src').split('-wide').join('');
							$(this).attr('src', src);
							$(this).attr('width', 280);
						});
						this.alreadyWide = false;
					}
				}
			}
			AdaptImageToScreenSize.alreadyWide = innerWidth > 690;
			if (AdaptImageToScreenSize.alreadyWide) {
				AdaptImageToScreenSize();
			}
			$(window).resize(AdaptImageToScreenSize);
		</script>
        <!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
        <!--<script>
            var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>-->
    </body>
</html>
