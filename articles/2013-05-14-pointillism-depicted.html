<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
  	<meta content="Benjamin Bill Planche" name="author">
		<meta content="Portfolio of Benjamin (Bill) Planche, aka Aldream. About image processing, computer graphics, web experiments,..." name="description">
		<meta content="aldream, benjamin, planche, bill, blog, web, image, graphics, mesh, tesselation, tween, cube, sphere" name="keywords">
		<meta content="index,follow" name="robots">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Aldream - Mesh Breeding</title>
        <meta name="viewport" content="width=device-width">

		<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro|Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="/css/normalize.css"/>
        <link rel="stylesheet" href="/css/main.css"/>
		<link href="/css/syntaxhighlighter_3.0.83/shCore.css" rel="stylesheet" type="text/css" />
		<link href="/css/syntaxhighlighter_3.0.83/shThemeDefault.css" rel="stylesheet" type="text/css" />
        <script src="/js/vendor/modernizr-2.6.2.min.js"></script>
    </head>
    <body id="blog">
			<!--[if lt IE 7]>
				<p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
			<![endif]-->

			<!-- Add your site or application content here -->
			<header id="main-header">
				<h1><a href="/">Aldream</a></h1>
				<nav id="menu-top">
					<ul>
						<a href="/blog"><li>Blog</li></a>
						<a href="/demo"><li>Demo</li></a>
						<a href="/projects"><li>Projects</li></a>
						<a href="/about"><li>About</li></a>
					</ul>
				</nav>
				<nav id="menu-top-mini">
					<ul>
						<li><a href="/blog" title="Blog"><img width=22 alt="Blog" src="/img/glyphicons-color/book-blue.png"/></a></li>
						<li><a href="/demo" title="Demo"><img width=25 alt="Demo" src="/img/glyphicons-color/eye-green.png"/></a></li>
						<li><a href="/projects" title="Projects"><img width=25 alt="Projects" src="/img/glyphicons-color/star-yellow.png"/></a></li>
						<li><a href="/about" title="About"><img width=25 alt="About" src="/img/glyphicons-color/user-red.png"/></a></li>
					</ul>
				</nav>
			</header>
			<section id="blog-article">
				<h1>Article</h1>
				<article class="span3">
					<div>
<h1>Mesh Breeding</h1>

<p>To conclude my series of articles describing the tricks I learned and used for the <a href="http://js1k.com/2013-spring/" title="JS1K 2013">JS1K Spring-2013 challenge</a>, I will now explain how <em><strong>Pointillism</em></strong> (js1k demo / local demo) was done, since it received such nice reviews.</p>
<p>I will thus cover the <strong>lightweight procedural method</strong> used to generate the landscape, and the <strong><em>pointillist-like rendering</em></strong> I will assume you read my previous articles (Mesh Breeding and especially Painter's Algorithm), since they already cover the main notions of 3D generation and rendering.

<h2>Generating the landscape</h2>

<p>The creation of fractal landscapes (https://en.wikipedia.org/wiki/Fractal_landscape) is a famous and well-covered subject in Computer Graphics. Using stochastic algorithms emphasizing realism or performance, the aim is to generate a landform (mountains, lakes, plateau,...) and then to <i>give life to it</i> by painting it using Nature's logic (light-green meadow in flat sunny areas, white snow clinging to peaks,...), or by populating it with other 3D objects (trees, buildings,... <small>which can also be procedurally generated btw</small>).</p>

<h3>Topography</h3>
<p>A simple landform (continuous surface without caves) can be represented by a 2D <em>heightmap</em>, a matrix containing the elevation of sampled points. If we get such a matrix, it is thus possible to convert it into a 3D landscape, by using its indices as x and y coordinates, and the elevation as z.</p>

<p>A method to generate such heightmap must respect some criteria. It must be <em>pseudo-random</em> (random enough to be stochastic and allow a wide range of landforms, but predictable enough to give some controls over it), exhibit <em>fractal behavior</em> (covering both the global molding and the detailed surface), and be <em>coherent</em>, ie without any discontinuity (unless we want special topographic features like cliffs).</em>

<p>Some noise functions meet those conditions. The <strong>Perlin (http://mrl.nyu.edu/~perlin/) Noise</strong> is especially famous and widely used, being quite easy to implement though giving smooth results.</p>

<p>Alas, &laquo; easy to implement &raquo; doesn't always means &laquo; short &raquo;. Even though it can be condensed in few lines, it was still too long for a 1K demo. I thus opted for another well-know method: the <strong>Midpoint-Displacement algorithm</strong>. Its main idea is, given a 2D grid containing various values, to insert intermediate ones between each couple. The new values are computed using the mean of the surrounding points and adding a small error to it to generate new details. The amplitude of the error must be inversely proportional to the iteration / to the distance between the points to give the fractal-like result (the addition of big errors in the first iterations gives the landscape its global shape while the following iterations add smaller and smaller details to the surface).</p>

<p>Here is a simple implementation of this algorithm for a 2D map, using modulos to evaluate the position of each points in the current square:</p>
<script type="syntaxhighlighter" class="brush: js"><![CDATA[
///
// Generate new intermediate points (and thus details) to the given heightmap, by using stochastic interpolation (Midpoint-Displacement algorithm).
// Parameters:
//	- currentMap : Array of points (square matrix)
//	- amplitude : Alterations amplitude
// Returns: New map, more detailed
///
function ComputeMidPointDisplacement(currentMap, amplitude) {
	var dim = Math.sqrt(currentMap.length)+.5|0;
	var newDim = 2*dim - 1; // We want to add 1 new element between each couple of them, so the size will increase of dim-1.
	var newMap = [];
	
	for (var i = newDim; i--;) for (var j = newDim; j--;) {
		var iMap = i*newDim + j,
			iSMap = dim*(i>>1) + j/2|0; // Index of the top-left corner of the square in the smaller matrix.
		// JS trick: Math.floor(X) = 0|X if X positive, and X>>Y = 0|(X/(2*Y))
		newMap[iMap] =
			i%2?
				j%2?// Element on an odd row and odd col: it corresponds to a square center, so we populate it as shown in the following ascii schema:
					// 1  0  1		with X representing the current element, and the numbers the weight used to compute the mean value.
					// 0  X  0		So here, we use the value of the corners of the parent square to get the value of the new point, and we add a small
					// 1  0  1		error to it.
					((currentMap[iSMap] + currentMap[iSMap+1] +currentMap[iSMap+dim] +currentMap[iSMap+dim+1]) / 4 + amplitude * (.5 - Math.random()))
					
				:	// Element on an odd row and even col: we give it the avg of the elements on the prev. and next cols:
					// 1  0  0		Example
					// X  0  0
					// 1  0  0
					(currentMap[iSMap] + currentMap[iSMap+dim]) / 2
			:
				j%2?// Element on an even row and odd col: we give it the avg of the elements on the prev. and next rows:
					// 1  X  1		Example
					// 0  0  0
					// 0  0  0
					(currentMap[iSMap] + currentMap[iSMap+1]) / 2
				:	// Element on an even row and even col: it's one of the square corners, so we just give it the orig. val.:
					currentMap[iSMap];
		
		// Just to keep the values into control (boundaries):
		if (newMap[iMap] > 1) { newMap[iMap] = 1; }
		if (newMap[iMap] < 0) { newMap[iMap] = 0; }
	}
	
	return newMap;
}
]]></script>

<p>One problem of this algorithm is the squared artifacts it generates. A variant has been developed, the <strong>Diamond-Square algorithm</strong>(https://en.wikipedia.org/wiki/Diamond-square_algorithm)(http://www.gameprogrammer.com/fractal.html), but this requires another step per square, lengthening the function. To <i>partially</i> prevent those artifacts without exceeding the size limit, I made a mix of both methods, using both points from the previous map and the already generated points from the new one to evaluate the value of the mid points:</p>

<script type="syntaxhighlighter" class="brush: js"><![CDATA[
		...
		newMap[iMap] =
			(i%2?
				j%2?// Element on an odd row and odd col: it corresponds to a square center, so we populate it as shown in the following ascii schema:
					// 3  0  0		with X representing the current element, and the numbers those used to eval. it.
					// 0  X  1		It's kind of a mix between the midpoint displacement and the diamond-square algo: we try to reduce the artifacts 
					// 0  1  1		the 1st algo may generate, without the 2nd step required by the other.
					(newMap[iMap+newDim] + newMap[iMap+1] + newMap[iMap+1+newDim] + 3*currentMap[iSMap]) / 6
					// or (newMap[iMap+newDim] + newMap[iMap+1] + 2*currentMap[iSMap]) / 4 if like me you don't have enough place for the extra weight.
					
				:	// Element on an odd row and even col: we give it the avg of the elements on the prev. and next cols:
					// 1  0  0		Example
					// X  0  0
					// 1  0  0
					(currentMap[iSMap] + currentMap[iSMap+dim]) / 2
			:
				j%2?// Element on an even row and odd col: we give it the avg of the elements on the prev. and next rows:
					// 1  X  1		Example
					// 0  0  0
					// 0  0  0
					(currentMap[iSMap] + currentMap[iSMap+1]) / 2
				:	// Element on an even row and even col: it's one of the square corners, so we just give it the orig. val.:
					currentMap[iSMap]
			) + amplitude * (.5 - Math.random()); // By adding errors to every point (even the previously fixed one), we lose in predictability but reduce a bit the visibility of the remaining artifacts.
		...
]]></script>

[[1D demo vs 1D demo with pseudo algo]]
[[2D demo vs 2D demo with pseudo algo]]
[[ adding some codes ]]

<h3>Coloring</h3>

<p>Given your heightmap, it's quite easy to <em>assign color to every point depending on its elevation</em>: if the value equals the min. boundary, then paint it light blue to represent water; if it's above a given limit then make it white as snow; if it's between then make a gradient from vegetal-green to rocky-brown with a function using the height ; ...</p>

<p>But getting a realist-enough result needs much tweaking, and also more inputs.</p>

<p>One of the keys to give more depth and realism to a landscape is to take <strong>lighting</strong> into account. Computing shadows is out of question given our 1K limit, but simulating penumbra is easy using the <strong>incline</strong>. The traditionnal method to evaluate how much sunlight a surface get is by computing the dot-product of the surface's normal (or local gradient) and the unit vector representing the direction from the center of the surface to the point representing the Sun. We thus get the value of the cosine of the angle between these two vectors - value which is proportional to the luminance of the surface. By multiplying it with the <em>reflectivity</em> of the surface (high for snow, low for vegetation, ...), you get your color's <em>lightness</em>.</p>

<p>Alas, here again, evaluating the local gradient and using a real dot-product was too long, so I approximated both operations by the following: $pseudoGrad[i,j]=(2*heightMap[i*dim+j+dim+1]-heightMap[i \cdot dim+j+dim]-heightMap[i \cdot dim+j+1]) \cdot 26$. The shifting and incompletness of the evaluation of the gradient and its projection simulate the dot-product with a sun positioned somewhere north-east of the map...</p>

<p>But we can use this value for <em>much more than simply evaluating the lightness</em>. Lighting also impacts directly the elements in the landscapes. For instance, vegetation isn't the same in sunny places than in the dark coombes. And the quantity of snow isn't only function of the elevation but also of the surface's penumbra. So by also using our pseudo-derivated value as input for the computations of the other color components (hue and saturation), we can give to our landscape much more nuances, simulating some natural phenomena.</p>

<p>For each point $(i,j, height)$ to display, I thus evaluate its color with the <i>highy-personal-and-not-so-reusable</i> following code (just so you can see the structure):</p>

<script type="syntaxhighlighter" class="brush: js"><![CDATA[
var pseudoGrad = 2+(2*heightMap[i*dim+j+dim+1]-heightMap[i*dim+j+dim]-heightMap[i*dim+j+1])*26,
	pseudoHeight = height-pseudoGrad;
ctx.fillStyle = ctx.strokeStyle = 'hsl('+[ // Using coercion for the ","
	25*(	// Hue
		(WATER_LVL<height)? 25/height					// Green to brown
		: 7 											// Blue
		), // can be approximated by: hue = 13.7*height*height-244*height+1143
	25*(	// Saturation	
		(WATER_LVL<height)? pseudoGrad*14/height/height	// Ground saturation: medium, depending on the incline/height, giving us different kinds of veget.
		: pseudoHeight									// Water saturation: high
		)+'%',
	(25*(	// Lightness
		(SNOW_LVL_DEC<pseudoHeight)? pseudoGrad					// Bright snow with random noise
		: (BEACH_LVL<height)? pseudoGrad/height*2				// Vegetation
		: (WATER_LVL<height)? pseudoGrad						// Bright sand
		: 1.8+Math.random()*.2									// Water with random waves
		))-6*Math.cos(i/47*Math.cos(height/3+j/57)+pseudoHeight)// Some not-very-random-but-good-enough shadows/lights (casted by clouds for instance)
]+'%)';
]]></script>

<p>&laquo;<i>It still looks ugly.</i>&raquo; Right, but we are adding relief effects to a flat surface, how can it look but disturbing? Let's now play with 3D.</p>

<h3>Put everything into relief</h3>
	
<p>Almost nothing new here. The whole projection and rendering stuff has been covered in the previous articles. We just have to take each point $(i, j, height)$ of the heightmap, evaluate the position of the corresponding vertex $(x, y, z)$ with $x = i * d$, $y = j * d$ ($d = landscape.size / heightmap.size$) and $z = height * k$ ($k$ constant), and then project it into screen coordinates.</p>
<p>To check if the point should be displayed or not, ie. if it isn't hidden behind other features, we could use again the Painter's algorithm. This is what I used for the demo Loom (XXXXXXXXXXX).</p>

[[ Loom ]]

<p>The problem of this method is that it implies to sort an array containing all the elements (simple vertices or surfaces) waiting to be drawn. That is quite a <i>heavy</i> operation, given the level of details of our landscape. This is why I have to reduce the details when moving around, or else the browser wouldn't be able to ensure a correct framerate <small>(and would probably crash)</small>. I was though satisfied with the result, and ready to publish it.</p>

<p>While polishing some aspect of the demo, I came accross this article (http://www.romancortes.com/blog/1k-rose) made by Román Cortés (XXXX) about his great entry for JS1K 2012 (http://js1k.com/2012-love/). There, he describes in details the rendering method he used, combining the use of a <strong>z-buffer</strong> and a <strong>Monte-Carlo surface sampling</strong>. I thus decided to try to apply it to my landscapes, and create a new demo.</p>

<p>The idea behind this method is the following:</p>
<ul>
	<li>We define our whole scene by a bijective function $f(a,b) = (x, y, z, color)$ with $(a,b) e [0,1]x[0,1]$ and $x$, $y$, $z$ the coordinates of the vertex matching the input. It implies to find a way to express each element as an explicit-surface with its own unique domain.</li>
	<li>We keep two buffers of the same size $canvas.width x canvas.height$: one for the $color$ values of the projected elements (the  <em>z-canvas</em>), and one for their $depth$ values (the <em>z-buffer</em>).
	<li><p>Each frame, we sample randomly a high number of points (a, b), evaluate the corresponding vertex using $f$, and project it into $(p_x, p_y, depth, color)$. If the pixel $(p_x, p_y)$ as already been drawn, we check the z-buffer:</p>
		<ul>
			<li>If $zBuffer[p_x, p_y] < depth$, it means the element is actually behind the one already drawn, so we do nothing.</li>
			<li>Else, the element should be represented above, so we update both $canvas[p_x, p_y]$ with $color$ and $zBuffer[p_x, p_y]$ with $depth$.</li>
		</ul>
	</li>
	<li>As long as the camera and scene are static, we can keep drawing more random points each frame, until reaching a satisfactory density. If movements are required, then both canvas and z-buffer must be cleared <small>(unless you keep the 3D information of each points and reproject them accordingly to the new transform.)</small></li>
<ul>
<p>However, we need some adaptations to use this method on our landscape. We don't have a continuous function to pick vertices out of our 2D discrete heightmap. We need a way to evaluate the height of the points all over our surface, and not only at the nodes. We need <strong>interpolation</strong>.</p>

<p>The easiest way to interpolate values XXXXXXXXXXXXXXXXXX

<h2>Rendering</h2>

<p>As it is better not to walk blind, let's deal first with the rendering of our yet-to-be-created scene. For that, we can use the simple renderer described in my previous article, so please <a href="/article/2013-04-13-painter-s-algorithm" title="Painter's Algorithm">read it</a> if you need the explanations.</p>
<p>Only minor modifications are required to adapt it to the specificity of our mesh structure. However, as we are limited in the number of bytes, we should also condense the whole, even if it means losing in clarity or generality <small>(the code below is still much <em>crush-able</em>, by condensing some operations for instance)</small>:</p>
	
	
<h2>Mesh weaving</h2>

<p>To get the shape-shifting object, the idea is the following: we generate two meshes, a cube and a sphere, with the <strong>same</strong> number of vertices/faces (each one is associated with an other one of the 2nd mesh). Then every frame, we compute an intermediate mesh from a <em>pseudo-tweening</em> between the geometries of the two original ones, and display it.</p>

<p>In this section, we will cover the creation of our two primitive meshes with as few bytes as possible.</p>

<h3>Cube</h3>
<p>The objective is to define a cube of size $D$, centered on the origin (to simplify the generation), and made of $6 \cdot N^2$ triangular faces ($N^2$ per side).
We could just statically define its structure, like I did in an example for the rendering:</p>
<script type="syntaxhighlighter" class="brush: js"><![CDATA[
// Definition of a simple 2x2x2 cube, made of quad faces
// (building the mesh procedurally isn't complicated, but not the subject of this article):
var cubeVertices = [[-1,  1,  1], [ 1,  1,  1], [ 1, -1,  1], [-1, -1,  1],
					[-1,  1, -1], [ 1,  1, -1], [ 1, -1, -1], [-1, -1, -1]];
var cubesQuadriFaces = [[cubeVertices[0], cubeVertices[1], cubeVertices[2], cubeVertices[3]],
						[cubeVertices[4], cubeVertices[5], cubeVertices[6], cubeVertices[7]],
						[cubeVertices[1], cubeVertices[5], cubeVertices[6], cubeVertices[2]],
						[cubeVertices[4], cubeVertices[0], cubeVertices[3], cubeVertices[7]],
						[cubeVertices[4], cubeVertices[5], cubeVertices[1], cubeVertices[0]],
						[cubeVertices[3], cubeVertices[2], cubeVertices[6], cubeVertices[7]]];
]]></script>
<p>But we want a more refined mesh, with more vertices to play with later, and writing down the coordinates of our $3 \cdot 6 \cdot N^2$ vertices would be as painful as long.
So... how can we <strong>procedurally</strong> define our cube? Here is a first possibility:</p>
<div class="mathjax-formula">
$$
C = \{S_0, S_1, S_2, S_3, S_4, S_5\}$$
</div>
<p>with each side defined as:</p>
<div class="mathjax-formula">
$$\begin{matrix}
	- S_0 :& \{& (x, y, z) \in S_0  &|&  \forall (x, y) \in [\frac{-D}{2}, \frac{D}{2}]^2& and& z = +\frac{D}{2}& \}\\
	- S_1 :& \{& (x, y, z) \in S_1  &|&  \forall (y, z) \in [\frac{-D}{2}, \frac{D}{2}]^2& and& z = -\frac{D}{2}& \}\\
	- S_2 :& \{& (x, y, z) \in S_2  &|&  \forall (z, x) \in [\frac{-D}{2}, \frac{D}{2}]^2& and& y = +\frac{D}{2}& \}\\
	- S_3 :& \{& (x, y, z) \in S_3  &|&  \forall (x, y) \in [\frac{-D}{2}, \frac{D}{2}]^2& and& z = -\frac{D}{2}& \}\\
	- S_4 :& \{& (x, y, z) \in S_4  &|&  \forall (y, z) \in [\frac{-D}{2}, \frac{D}{2}]^2& and& x = +\frac{D}{2}& \}\\
	- S_5 :& \{& (x, y, z) \in S_5  &|&  \forall (z, x) \in [\frac{-D}{2}, \frac{D}{2}]^2& and& z = -\frac{D}{2}& \}
\end{matrix}
$$
</div>
<p>Do you see the pattern? Here is a condensed definition, for $n \in \{0,\dots,5\}$:</p>
<div class="mathjax-formula">
$$\begin{matrix}
	- S_n : \{&v = (x , y, z),&(v[n \bmod 3], v[(n+1) \bmod 3], v[(n+2) \bmod 3)]) \in S_n &|& \forall (x, y) \in [-\frac{D}{2}, \frac{D}{2}]^2& and& z = \frac{D}{2} - D \cdot (n \bmod 2)& \}
\end{matrix}
$$
</div>
<p>We use a <i>modulo 3</i> operation to express the cyclic permutation of the coordinates (the two varrying and the one fixed), and a <i>modulo 2</i> operation to define the value of the fixed coordinate. With this, we cover the 6 cases...</p>

<p>The only thing left is to split the sides into triangular faces <small>(if you want to use quadfaces, the modifications are minor)</small>, which can be easily achieved with loops to sample a regular repartition of vertices and the faces:</p>
<ul>
	<li>One loop to iterate over the <strong>6 sides</strong>;</li>
	<li>Two loops to iterate over our subdivisions of our sides into <strong>N² rectangles</strong>;</li>
	<li>One loop of 2 iterations to divide each rectangle into the <strong>2 triangular faces</strong>.</li>
</ul>
<p>The final generation method is:</p>
<script type="syntaxhighlighter" class="brush: js"><![CDATA[
/**
 * ===GenerateVertexForCube===
 * Given the subdivision indices, generates the corresponding vertex for the cube mesh
 *(centered on the origin), and gives it to the current triangle faces.
 * Parameters:
 *	- i 	(Int):			Row num
 *	- j 	(Int): 			Col num
 *	- n 	(Int): 			Side of the cube we are currently dealing with
 *	- face 	(Array<float>): Face the vertex will belong to
 */
function GenerateVertexForCube (i, j, n, face) {
	// First we generate the cube vertex. Using some modulos on the side index,
	// we can cover each case, by swapping the coordinates order or moving the vertex along the depth axis:
	var v = [i/NB_DIV*SIZE-RADIUS, j/NB_DIV*SIZE-RADIUS, RADIUS*(1-2*(n%2))], 
		x = v[n%3],
		y  = v[(n+1)%3],
		z = v[(n+2)%3];
	face.push(x, y, z);
}

var facesCube=[],	// Mesh
	NB_DIV = 16,	// Number of rows and colums per cube's side, which means our meshes will be made of 6*16*16 vertices
	SIZE = 4,		// Dimension of our meshes
	RADIUS = SIZE/2,// Mid-dim
	trId = 0;
	
// To save some bytes, we iterate desc. The idea is that for each element we iterate on,
// we evaluate the triangles faces of the square which as for top-left corner this element:
for (var n = 6; n--;)
	for (var i=NB_DIV; i--;)
		// X --- o	Schema representing the faces extracted from a square. X is the current element.
		// |  \  |
		// o --- o
		for (j = NB_DIV; j--;) for (k=2;k--;) // We iterate 2 times for each square in order to generate the 2 corresponding triangle-faces.
			// We store each face information into an array [V1.X, V1.Y, V1.Z, V2.X, V2.Y, V2.Z, V3.X, V3.Y, V3.Z, dist(V3, center)]:
			facesCube[trId] = [],
			GenerateVertexForCube(i,j, n, facesCube[trId]), 		// 1st vertex (top-left corner of the square)
			GenerateVertexForCube(i+1,j+1, n, facesCube[trId]),		// 2nd vertex (bottom-right)
			GenerateVertexForCube(i+k, j+1-k, n, facesCube[trId]),	// 3rd vertex - the one varying (either corresponding to the element on the next row,
																// or the one on the next col). We use a modulo 2 on the face's id to select the good one.
			// Byte saving trick:(faceId+1)%2 = k. And we don't mind which triangle we generate first, so k makes a cheaper way to distinguish them
			trId++;
]]></script>

<div class="example">
	<iframe width=320 height=230 class="demo" src="/examples/cube-tesselation.html"></iframe>
	<p>Resulting cube</p>
</div>

<h3>Sphere</h3>
<p>Now we want a sphere of diameter $D$, made of the same number $6 \cdot N^2$ of faces.</p>
<p>There are many possible ways to tesselate a sphere, but we have one condition we wish to fulfill: to get a <em>smooth transition when tweening</em> the geometries of our cube and sphere. So we are looking for a <em>similar</em> repartition of the vertices.</p>

<p>The <strong>quadcube tesselation</strong> (or <em>cubic sphere tesselation</em>) is what we want for our sphere. This method is commonly used to map flat textures to spheres, but can also be adapted to generate their mesh.<a class="refing" id="refing-1" href="#refed-1" title="Ref - Acko.net - Making Worlds 1 - Of Spheres and Cubes">[1]</a></p>
<p>The idea is to take a regular cube mesh (so like the one we generated), and to project every vertex on the spherical surface, by normalizing the length of the vector to the center of the mesh, to the value we want as radius.</p>
<p>In other words, for every vertex, we compute their distance to the center, divide their coordinates by the obtained value, and multiplie them back with the radius value.</p>

<div class="example">
	<iframe width=320 height=230 class="demo" src="/examples/cube-sphere-linear-tweening-2D.html"></iframe>
	<p>2D example - Gradual normalization of the vectors length</p>
</div>

<p>Thus, by just adding these two operations to our previous tesselation function, we can return a sphere instead of a cube (or both):</p>

<script type="syntaxhighlighter" class="brush: js"><![CDATA[
/**
 * ===GenerateVertexForCube===
 * Given the subdivision indices, generates the corresponding vertex for the cube mesh
 *(centered on the origin), and gives it to the current triangle faces.
 * Parameters:
 *	- i 	(Int):			Row num
 *	- j 	(Int): 			Col num
 *	- n 	(Int): 			Side of the cube we are currently dealing with
 *	- faceC (Array<float>): Face of the cube the vertex will belong to
 *	- faceS (Array<float>): Face of the sphere the vertex will belong to
 */
function GenerateVertexForCubeAndSphere (i, j, n, faceC, faceS) {
	// First we generate the cube vertex. Using some modulos on the side index,
	// we can cover each case, by swapping the coordinates order or moving the vertex along the depth axis:
	var v = [i/NB_DIV*SIZE-RADIUS, j/NB_DIV*SIZE-RADIUS, RADIUS*(1-2*(n%2))], 
		x = v[n%3],
		y  = v[(n+1)%3],
		z = v[(n+2)%3];
	faceC.push(x, y, z);
	
	// Then the sphere vertex, by "cube-mapping" (the following formula speaks for itself):
	var dist = Math.sqrt(x*x + y*y + z*z);
	faceS.push(x/dist*RADIUS, y/dist*RADIUS, z/dist*RADIUS);
	
	// return dist; // Value used in the demo to define the color of each face.
}

var facesCube=[],	// Cube Mesh
	facesSphere=[],	// Sphere Mesh
	NB_DIV = 16,	// Number of rows and colums per cube's side, which means our meshes will be made of 6*16*16 vertices
	SIZE = 4,		// Dimension of our meshes
	RADIUS = SIZE/2,// Mid-dim
	trId = 0;
	
for (var n = 6; n--;)
	for (var i=NB_DIV; i--;)
		// X --- o	Schema representing the faces extracted from a square. X is the current element.
		// |  \  |
		// o --- o
		for (j = NB_DIV; j--;) for (k=2;k--;) // We iterate 2 times for each square in order to generate the 2 corresponding triangle-faces.
			facesCube[trId] = [],
			facesSphere[trId] = [],
			GenerateVertexForCube(i,j, n, facesCube[trId], facesSphere[trId]), 			// 1st vertex (top-left corner of the square)
			GenerateVertexForCube(i+1,j+1, n, facesCube[trId], facesSphere[trId]),		// 2nd vertex (bottom-right)
			GenerateVertexForCube(i+k, j+1-k, n, facesCube[trId], facesSphere[trId]),	// 3rd vertex - the one varying
			trId++;
]]></script>



<div class="example">
	<iframe width=320 height=230 class="demo" src="/examples/sphere-tesselation.html"></iframe>
	<p>Resulting sphere</p>
</div>
	
<h2>Mingle Mingle Little Mesh</h2>

<p>The next step is the <strong>dynamic generation of our <em>metis</em> shape</strong>. For every couple of vertices from the cube and sphere, we simply want to calculate an intermediate one.</p>

<div class="example">
	<iframe width=320 height=230 class="demo" src="/examples/cube-sphere-linear-tweening-3D.html"></iframe>
	<p>3D example - Linear tweening between the 2 meshes</p>
</div>

<p>We could use a linear tweening over time, like in the example above... or go for something <em>crazier</em>.
Basically, you can use any function you want, taking as parameters, among others, your two vertices, and returning a new, more-or-less correlated, one.</p>
<p>I spent much time time tweaking around such a function to get something visually interesting. Here are some observations I made which could help you create your own:</p>
<ul>
	<li><strong>Parameters</strong>
		<ul>
			<li>Taking <strong>time</strong> into consideration seemed evident in my case.</li>
			<li>I also adopted the <strong>distance of the corresponding face to the center of the mesh</strong>. It allowed me to apply transforms per face: combined with the <em>looseness</em> of our structure (see first section), it's how I get the implosive-kaleidoscopic result.</li>
			<li><strong>Interactivity is always nice</strong>: I take the user's clicks into account, but you can think of other inputs.</li>
			<li>An idea I couldn't integrate to my demo was the use of an <strong>external signal</strong> as main parameter. You could easily make your object <strong>dance</strong> to the music of your liking...</li>
		</ul>
	</li>	
	<li><strong>Functions</strong>
		<ul>
			<li>Compute the <strong>cosine</strong> values of the smoothly-varying parameters to get some periodicity.</li>
			<li>Use different <strong>prime numbers as coefficients</strong> (periods) to make the global periodicity less obvious.</li>
			<li>Why restricting ourselves to the segment between our two original vertices? Go beyond (ie try to apply <strong>coefficients beyond [0, 1]</strong> to thstrong).</li>
			<li><strong>Cubic pulsations</strong> is an interesting effect I abused to deal with the sudden inputs (clicks) (learn more about at the source of the idea, Iñigo Quílez's website <a class="refing" id="refing-2" href="#refed-2" title="Ref - Iñigo Quílez - Article - Useful Little Functions">[2]</a> <small>- this website is full of coding and maths gems</small>)</li>
		</ul>
	</li>
</ul>
		
<p>Once you got the wanted effect, just wrap it all in a function you'll call in your rendering method:</p>

<script type="syntaxhighlighter" class="brush: js"><![CDATA[
///
// Linear tweening...
// Parameters:
//	- cubeCoord - Coordinate from the 1st mesh
//	- sphereCoord - Coordinate from the 2nd mesh
// Returns: the "intermediate" value
///
function Tween (cubeCoord,sphereCoord, coef) {
	return cubeCoord*coef + sphereCoord*(1-coef); // Replace with your funky mingling effect.
}

///
// Projects and renders the scene with mingling.
///
function Paint (facesCube, facesSphere) {
	// PROJECTION:
	/** ...
	 *	Usual initialization here
	 * 	... */
	
	for (l in facesCube) {  // Not optimal, but shorter.
		screenCoord[l] = [];
		var baryDepth = 0;
		for (j = 9;j;) {
			// We compute the tweened vertex and its projection:
			var vX = Tween(facesCube[l][--j], facesSphere[l][j], coefTween) + camDist*cosPitch,
				vY = Tween(facesCube[l][--j], facesSphere[l][j], coefTween) + camDist*sinPitch*cosYaw,
				vZ = Tween(facesCube[l][--j], facesSphere[l][j], coefTween) + camDist*sinPitch*sinYaw,
					
			/** ...
			 *	Usual projection here, using vX, vY, vZ instead of the original coordinates.
			 * 	... */
		}
	}
	
	// PAINTING:
	/** ...
	 *	Usual rendering here
	 * 	... */
}
]]></script>

<p>Below a small application displaying the outcome of some effects:</p>

<div class="example">
	<iframe width=600 height=300 class="demo" src="/examples/cube-sphere-various-tweenings.html"></iframe>
	<p>Various examples of mingling</p>
</div>

<h2>Polishing: Colors and movements</h2>

<p>Here again, it's all about personal tastes.</p>
<p>For the coloring, I opted for a dynamic solution: the color of each face is computed just before drawing it. I use this dynamism to <strong>vary the hue over time</strong>, but also to apply a <strong>pseudo depth fog</strong>.</p>
<p>This effect is obtained by using the <em>index of the sorted faces</em> as coefficient for the luminosity (here, the further from the camera, the smaller its index, the smaller the coefficient for luminosity and thus the darker).</p>
<p>By the way, I now only swear by the <strong>HSL color system</strong>. If it is not the case yet, I highly recommend you to consider it, at least when it comes to represent complex scenes.</p>

<script type="syntaxhighlighter" class="brush: js"><![CDATA[
	// Method used in the demo to compute the colors - called in the painting loop.
	a.fillStyle = a.strokeStyle='hsl('+[
		500*timeCos/screenCoord[l][9],	// Hue - Function of the time and of the original distance
										//		to the origin.
		'50%',							// Saturation - constant
		l/75*Math.cos(pulseCoef/7)		// Luminosity - Function of the periodic pulse + Cheap fog
										//		effect by using the sorted index
	]+'%)',
]]></script>

<p>As for the camera's movements, the shape-shifting function was already inducing <em>momentum</em>, inflating or deflating the mesh's dimensions.</p>
<p>Indeed, one consequence of having a scene containing a single element is the <strong>absence of landmarks</strong>. Without looking at the source, it is left to the viewer's appreciation to conclude if it is the camera which is nearing or the object which is growing.</p>
<p>I decided to only add rotations around the center of the scene (over time + binded to the mouse position), to emphasize the 3D nature of the demo.</p>

<p>At that point, I was kind of satisfied with the result. Only one effect was somehow hurting my sensibility, literally speaking: the <em>collision between the inflated shape and the camera</em>.</p>
<p>As much as I wanted to preserve the eye-catching unpredictability of the morphose, I found unaesthetic the obstructed effect of some collisions, when the object was imploding or stretched to its limit.</p>
<p>While trying to adapt the rendering method to ignore the colliding faces, I inadvertently altered my Painter's method, <strong>inverting the depth sorting</strong>... and enjoyed the resulting sight.</p>
<p>The solid, material, aspect of the object was lost, but that nicely solved my problem: the too-near faces which the camera was colliding with were now painted under the further ones. Instead of hitting the object's surface, we were now observing it as if inside.</p>
	
<h2>Conclusion</h2>

<p>Even if most of those methods are already covered by 3D libraries, it may come handy to know the maths or logic under. This knowledge is one of the main reasons why I enjoyed working on those small applications.</p>
<p>After all, &laquo; <em>Don't Reinvent The Wheel, Unless You Plan on Learning More About Wheels</em> &raquo;... <a class="refing" id="refing-3" href="#refed-3" title="Ref - CodingHorror.com - Don't Reinvent The Wheel, Unless You Plan on Learning More About Wheels">[3]</a></p>

<h3>References</h3>
<ol>
	<li id="refed-1"><a class="refed" href="#refing-1">^</a> Steven Wittens - Article - &laquo; Making Worlds 1 - Of Spheres and Cubes &raquo; - <a href="http://acko.net/blog/making-worlds-1-of-spheres-and-cubes/" title="Steven Wittens - Article - &laquo; Making Worlds 1 - Of Spheres and Cubes &raquo;">acko.net/blog/making-worlds-1-of-spheres-and-cubes</a></li>
	<li id="refed-2"><a class="refed" href="#refing-2">^</a> Iñigo Quílez - Article - &laquo; Useful Little Functions &raquo; - <a href="http://www.iquilezles.org/www/articles/functions/functions.htm" title="Iñigo Quílez - Article - &laquo; Useful Little Functions &raquo;">iquilezles.org/www/articles/functions/functions.htm</a></li>
	<li id="refed-4"><a class="refed" href="#refing-'">^</a> Jeff Atwood: &laquo; Don't Reinvent The Wheel, Unless You Plan on Learning More About Wheels &raquo; - <a href="http://www.codinghorror.com/blog/2009/02/dont-reinvent-the-wheel-unless-you-plan-on-learning-more-about-wheels.html" title="Jeff Atwood: &laquo; Don't Reinvent The Wheel, Unless You Plan on Learning More About Wheels &raquo;">codinghorror.com/blog/2009/02/dont-reinvent-the-wheel-unless-you-plan-on-learning-more-about-wheels.html</a></li>
</ol>
						<footer>
							<time datetime="2013-04-13">2013-04-23</time>
							<a href="https://twitter.com/share" class="twitter-share-button" data-text="The Painter'S Algorithm" data-via="b_aldream" data-lang="en">Tweet</a>
						</footer>
						<div id="disqus_thread"></div>
						<script type="text/javascript">
							/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
							var disqus_shortname = 'aldream'; // required: replace example with your forum shortname

							/* * * DON'T EDIT BELOW THIS LINE * * */
							(function() {
								var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
								dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
								(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
							})();
						</script>
						<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
							<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
							
					</div>
				</article>
			</section>
			<footer id="page-footer">&copy; Aldream / Benjamin (Bill) Planche 2013 - <a href="#blog-article" title="Up">Fly high</a></footer>


        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="/js/vendor/jquery-1.9.0.min.js"><\/script>')</script>
        <script src="/js/plugins.js"></script>
        <script src="/js/main.js"></script>
		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({
				TeX: { extensions: ["autobold.js"] },
				tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
			});
		</script>
		<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
		<script type="text/javascript" src="/js/vendor/syntaxhighlighter_3.0.83/shCore.js"></script>
		<script type="text/javascript" src="/js/vendor/syntaxhighlighter_3.0.83/shBrushJScript.js"></script>
		<script>
			// Syntax Highlighting:
			SyntaxHighlighter.all()
			
			// Twitter buttons:
			!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
			
			function AdaptImageToScreenSize() {
				if (innerWidth > 690) {
					if (!this.alreadyWide) {
						$('.wideImg').each(function(){
							var src = $(this).attr('src');
							var srcArray = src.split('.');
							src = srcArray.pop();
							src = srcArray.join('.') + '-wide.' + src;
							$(this).attr('src', src);
							$(this).attr('width', 620);
						});
						this.alreadyWide = true;
					}
				}
				else {
					if (this.alreadyWide) {
						$('.wideImg').each(function(){
							var src = $(this).attr('src').split('-wide').join('');
							$(this).attr('src', src);
							$(this).attr('width', 280);
						});
						this.alreadyWide = false;
					}
				}
			}
			AdaptImageToScreenSize.alreadyWide = innerWidth > 690;
			if (AdaptImageToScreenSize.alreadyWide) {
				AdaptImageToScreenSize();
			}
			$(window).resize(AdaptImageToScreenSize);
		</script>
        <!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
        <!--<script>
            var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>-->
    </body>
</html>
