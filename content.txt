Cet article est le premier d'une serie ayant pour but de decrire et formaliser les differentes methodes et tricks utilises dans mes 3 demos pour js1k 2013. Les principaux themes abordes seront donc la generation procedural d'elements 3D, leur rendering, et comment faire rentrer tout ca sur 1024 bytes.

For today, we will deal with "how to easily render my 3D scene in a 2D canvas", presenting one of the simplest method for that: the Painter's Algorithm.

Rendering process

You have at hand your various 3D meshes, nicely placed in a scene, and now you wonder how to render that into a static picture or a dynamic demo... Le procede general est relativement simple:
- Definir la camera (position, orientation, field of view,...)
- Projeter vos 3D meshes sur son viewfinder 2D plan
- Reporter et dessiner les elements visibles sur votre canvas

----------------

The projection step is quite straightforward (we will suppose you want a perspective projection). 

[ Expliquer les maths derriere ]

[Matrix Formula]
This matrix formula looks good, but can be laborious to use if you can't afford to include a library dealing with matrix operations. So let's linearize it. We thus get (thanks Wikipedia for saving me from this burden):
[Linear Formula]

Nothing we can't implement here. Moreover, you can observe some recurrences in it, which means it is possible to refactore it to save some operations and bytes:
[Refactored Formula]

We now can compute the positions of 3D elements with respect to the coordinate system defined by our camera (with X and Y are the projection position on the viewfinder and Z the perspective/the depth seen from the camera). 
[Expliquer projection dans image]

So here is our final projection function, to be applied to every vertex of our scene:
[Function // expliquer que le clipping est fait par le canvas]

----------------

The keyword here is "visible". We don't want to draw our elements higgledy-piggledy, displaying faces which should be hidden under others. We want to respect the depth order while rendering. And that's exactly what the Painter's algorithm is for.
The idea is quite simple: before drawing our elements, we just sort them by decreasing depth (so from the furthest from the camera position to the closest). By drawing them in this order, the front elements will naturally cover/overlay the ones behind. Like most painters would do.
Luckily for us, if you remember well, our projection function already computes the depth of the vertices, making the implementation of the rendering function really straightforward:
[Function]

And that's all. We just implemented a really simple 3D renderer (which can be quite useful, for instance if you are dealing with 3D objects in a project, and you need to display them only for testing, and thus don't want to deal with new dependencies just for that... Well, it did happen to me).

But don't be fooled: when I say "simple renderer", I also mean "too simple". The Painter's algorithm has many drawbacks, such as:
- It draws stuff which finally won't be displayed (hidden under). Far from optimal... (unless you have semi-transparent objects in your scene: this flaw becomes a cheap way to automatically manage the transparency)
- It is "face-wise", ie. it draws face per face, and not pixel per pixel like some other methods. We thus lose in precision (the pixel-wise solutions give you the possibility to compute textures more precisely - pixel per pixel), and we can also face some rendering glitches, for instance in the case of overlapping or piercing polygons (how to order thoses faces?)
- As implemented here, we don't know which element is above/under which one. This information could be useful to apply some effects, such as shadows (see for example the [http://web.cs.wpi.edu/~matt/courses/cs563/talks/shadow/shadow.html]Shadow Z-buffer algorithm).

That being said, this method can still be applied to many cases

=====================================================
Morphose - Explanations

Morphose is the first demo I posted in js1k 2013.

The main idea is the following: I generate two meshes, a cube and a sphere, with the same number of vertices/faces (each one is associated with an other one of the 2nd mesh). Then every frame, I compute an intermediate mesh from a pseudo-tweening between the geometries of the two original ones, and display it. Add some colors and interactions, and voila!
Now let's dig into the details of each step:

Mesh generation

	First we'll deal with the creation of our two meshes, the cube and the sphere, with as few bytes as possible.
	
Cube
	The objective is to define a cube of size D, centered/oriented on the origin (to simplify the generation), and made of 6*N^2 triangular faces (N^2 per side).
	So... how can we define our cube? Here is a first possibility:
	- C = {S0, S1, S2, S3, S4, S5} with:
		- Side S0 : { (x, y, z) e S0 if x and y e [-D/2, D/2] and z = +D/2 }
		- Side S1 : { (x, y, z) e S1 if y and z e [-D/2, D/2] and x = +D/2 }
		- Side S2 : { (x, y, z) e S2 if z and x e [-D/2, D/2] and y = +D/2 }
		- Side S3 : { (x, y, z) e S3 if x and y e [-D/2, D/2] and z = -D/2 }
		- Side S4 : { (x, y, z) e S4 if y and z e [-D/2, D/2] and z = -D/2 }
		- Side S5 : { (x, y, z) e S5 if z and x e [-D/2, D/2] and z = -D/2 }
		
	Do you see the pattern? Here is a condensed definition:
	- C = {Sn, n e [0,5]} with:
		- Side Sn : { v = (x , y, z), (v[n%3], v[(n+1)%3], v[(n+2)%3)]) e Sn if x and y e [-D/2, D/2] and z = D/2 - D*(n%2) }
	(Note: the faces numbers are not consistent with the previous definition)
	
	We use a modulo 3 operation to express the cyclic permutation of the coordinates (the two varrying and the one fixed), and a modulo 2 operation to define the value of the fixed coordinate. With this, we cover the 6 cases...

	The only thing left is to split the sides into triangular faces, which can be easily achieved with loops. The final generation method is:
	[Code]
	
Sphere
	Now we want a sphere of diameter D, made of the same number 6*N^2 of faces.
	There are many possible ways to tesselate a sphere, but we have one condition we wish to fulfill: to get a smooth transition when tweening the geometries of our cube and sphere. So we want a *similar* repartition of the vertices.
	
